/*在一个 8 x 8 的棋盘上，有一个白色车（rook）。
也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。
它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。
车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），
然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。
另外，车不能与其他友方（白色）象进入同一个方格。

返回车能够在一次移动中捕获到的卒的数量。

示例 1：
输入：[[".",".",".",".",".",".",".","."],
[".",".",".","p",".",".",".","."],
[".",".",".","R",".",".",".","p"],
[".",".",".",".",".",".",".","."],
[".",".",".",".",".",".",".","."],
[".",".",".","p",".",".",".","."],
[".",".",".",".",".",".",".","."],
[".",".",".",".",".",".",".","."]]
输出：3
解释：
在本例中，车能够捕获所有的卒。

示例 2：
输入：[[".",".",".",".",".",".",".","."],
[".","p","p","p","p","p",".","."],
[".","p","p","B","p","p",".","."],
[".","p","B","R","B","p",".","."],
[".","p","p","B","p","p",".","."],
[".","p","p","p","p","p",".","."],
[".",".",".",".",".",".",".","."],
[".",".",".",".",".",".",".","."]]
输出：0
解释：
象阻止了车捕获任何卒。

示例 3：
输入：[[".",".",".",".",".",".",".","."],
[".",".",".","p",".",".",".","."],
[".",".",".","p",".",".",".","."],
["p","p",".","R",".","p","B","."],
[".",".",".",".",".",".",".","."],
[".",".",".","B",".",".",".","."],
[".",".",".","p",".",".",".","."],
[".",".",".",".",".",".",".","."]]
输出：3
解释：
车可以捕获位置 b5，d6 和 f5 的卒。*/

//解题思路：
//1.先确定白车R的位置并保存
//2.以白车的位置为基准，向上下左右进行遍历判断
//3.若遇到黑卒，累加退出;遇到白象就直接退出

#include<stdio.h>
int numRookCaptures(char** board, int boardSize, int* boardColSize);

int main(){
    char  board[8][8] = {{'.','.','.','.','.','.','.','.'},
                     {'.','.','.','p','.','.','.','.'},
                     {'.','.','.','p','.','.','.','.'},
                     {'p','p','.','R','.','p','B','.'},
                     {'.','.','.','.','.','.','.','.'},
                     {'.','.','.','B','.','.','.','.'},
                     {'.','.','.','p','.','.','.','.'},
                     {'.','.','.','.','.','.','.','.'}};
    char (*b)[8] = board;
    char *a = &(*(*b+0));
    int  boardColSize = 8;

    printf("%d",numRookCaptures(&a, 8, &boardColSize));

    return 0;
}

int numRookCaptures(char** board, int boardSize, int* boardColSize){
    int res=0;
    for(int i=0; i<boardSize; i++){
        for(int j=0; j<*boardColSize; j++){
            if(board[i][j]){
                for(int l=j-1; l>=0; l--){
                    if(board[i][l] == 'B'){
                        break;
                    }else if(board[i][l] == 'p'){
                        res++;
                        break;
                    }
                }

                for(int r=j+1; r<*boardColSize; r++){
                    if(board[i][r] == 'B'){
                        break;
                    }else if(board[i][r] == 'p'){
                        res++;
                        break;
                    }
                }

                for(int u=i-1; u>=0; u--){
                    if(board[u][j] == 'B'){
                        break;
                    }else if(board[u][j] == 'p'){
                        res++;
                        break;
                    }
                }

                for (int d=i+1; d<boardSize; d++){
                    if(board[d][j] == 'B'){
                        break;
                    }else if(board[d][j] == 'p'){
                        res++;
                        break;
                    }
                }
                
            }
            return res;
        }
    }
    return res;
}